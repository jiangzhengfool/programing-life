会。 java 导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收， 这就是 java 中内存泄露的发生场景。

1. 集合类，集合类仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。这一点其实也不明确，这个集合类如果仅仅是局部变量，根本不会造成内存泄露，在方法栈退出后就没有引用了会被 jvm 正常回收。而如果这个集合类是全局性的变量（比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它），那么没有相应的删除机制，很可能导致集合所占用的内存只增不减，因此提供这样的删除机制或者定期清除策略非常必要。

2. 单例模式。不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被 jvm 正常回收，导致内存泄露 ，考虑下面的例子：

class A{
public A(){B.getInstance().setA(this);
}
....
}
//B 类采用单例模式
class B{
private A a;
private static B instance=new B();
public B(){}
public static B getInstance(){
return instance;
}
public void setA(A a){
this.a=a;
}
//getter...
}
显然 B 采用 singleton 模式，他持有一个 A 对象的引用，而这个 A 类的对象将不能被回收。想象下如果 A 是个比较大的对象或者集合类型会发生什么情况。

上面所讲的这些也启发我们如何去查找内存泄露问题，在代码复审的时候关注长生命周期对象：全局性的集合、单例模式的使用、类的 static 变量等等 。在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋空。最好遵循谁创建谁释放的原则。