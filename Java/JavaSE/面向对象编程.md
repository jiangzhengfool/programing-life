## 多态时成员的特点?
- 成员变量  编译和运行都参考等号的左边。覆盖只发生在函数上，和变量没关系
- 成员函数(静态)  编译看左边，运行看右边。因为成员函数存在覆盖特性
- 静态函数  编译和运行都看左边。静态函数不具备多态性，多态性是对象的多态性，然后静态函数不涉及对象。

## 一个对象的创建过程(类加载的过程)
[从Java类到对象的创建过程都做了些啥？内存中的对象是啥样的？](https://www.jianshu.com/p/ebaa1a03c594)

## [为什么要使用内部类？](https://blog.csdn.net/feelang/article/details/39401125)
Java不支持多继承，当我们想继承多个类或者实现多个抽象类的时候，不得不借助于内部类来“继承多个类”

## [为什么匿名内部类和局部内部类在局部位置上只能访问局部中被final修饰的局部变量](https://blog.csdn.net/xyls12345/article/details/36628863)
定义为final后，编译程序的实现方法：将所有的局部内部类对象要访问的final型局部变量，都拷贝成为该内部类对象中的一个数据成员。这样，即使栈中局部变量（含final）已死亡，但由于它是final,其值永不变，因而局部内部类对象在变量死亡后，照样可以访问final型局部变量。

## java的继承中的构造方法
如果父类没有无参构造函数，创建子类时，不能编译，除非在构造函数代码体中第一行，必须是第一行显式调用父类有参构造函数

如果不显示调用父类有参构造函数，系统会默认调用父类无参构造函数super();但是父类中没有无参构造函数，那它不是不能调用了。所以编译就无法通过了.

创建有参构造函数后，系统就不再有默认无参构造函数。.如果没有任何构造函数，系统会默认有一个无参构造函数